# MTZTableViewManager
MTZTableViewManager is a powerful framework that allows you to create table views in a descriptive way, by specifying rows and sections without having to bother with indexes. It also provides a set of tools for creating forms and handling their input, applying masks, performing validations and converting to and from complex objects.

# Installation

## Manual
- Drop the file `MTZTableViewManager.xcodeproj` inside your Xcode project. 
- Make sure your submodules are up-to-date.
- Drag the `MTZTableViewManager.framework` (under `Products`) to your target `Linked Frameworks and Libraries` area.

## CocoaPods
You can also declare the following on your `Podfile`:
```ruby
pod 'MTZTableViewManager', '~> 1.0.1'
```
*Note that this will also add `MTZExpirationDatePicker` as a pod dependency.*

# Sample Usage

## Rows, sections and data
Getting started is fairly simple. Just declare a strongly-held `MTZTableManager` somewhere:
```objc
@property (nonatomic) MTZTableManager *tableManager;
```
Then declare your rows, sections and finally the data. Using a custom `UITableViewCell` subclass is recommended.
```objc
MTZTableRow *row = [[MTZTableRow alloc] initWithClazz:[MyCustomCell class] action:^(NSIndexPath * _Nonnull indexPath, id<MTZModel> model) {
        NSLog(@"Tap!");
    }];
MTZTableSection *section = [[MTZTableSection alloc] initWithTableRows:@[row]];
MTZTableData *data = [[MTZTableData alloc] initWithTableSections:@[section]];
self.tableManager = [[MTZTableManager alloc] initWithTableView:self.tableView tableData:data];
```
And you're good to go! Please note you cannot be the `tableView`s delegate or data source while using `MTZTableManager`. 

* You can also provide a regular and/or expanded height to a row, and it will toggle between them upon selection.
* You can also hide rows or sections dinamically, just set the `hidden` property.
* You can instantiate cells using `nib`s as well. Likewise you can provide custom headers and footers classes for every section.

### Models
To declare an object as a possible model, just conform it to `MTZModel`:
```objc
@interface MyCustomCellModel: NSObject<MTZModel>
@property (nonatomic) NSString *text;
@end
```

Cells can then be configured to display information. Simply conform the cell you want to `MTZModelDisplaying` and implement the required method:
```objc
@interface MyCustomCell: UITableViewCell <MTZModelDisplaying>
@end

@implementation MyCustomCell
- (void)configureWithModel:(id<MTZModel>)model {
    self.textLabel.text = ((MyCustomCellModel *)model).text;
}
@end
```

* Sections can also have models, and they're provided to custom headers/footers, if any, as long as their classes also conform to `MTZModelDisplaying`.

## Forms
### Form objects
Form objects are objects that can be manipulated by a form generated by `MTZTableViewManager`. Ideally, you want to make all of its properties read-only to avoid external mutation, since the form elements will modify the values directly via `KVO`. If you're using Swift. Don't forget the `dynamic` keyword for that! Make sure the object conforms to `MTZFormObject`:
```objc
@interface MyCustomFormObject: NSObject <MTZFormObject>
@property (nonatomic, readonly) NSString *title;
@property (nonatomic, readonly) NSDate *date;
@property (nonatomic, readonly) MyCustomUser *user;
@end
```

### Form rows
For a cell to be compatible with a form, it needs to conform with `MTZFormEditing` and implement the required method:
```objc
@interface MyCustomTextFieldCell: UITableViewCell <MTZFormEditing>
@property (nonatomic) UITextField *textField;
@end

@implementation MyCustomTextFieldCell
// ...
- (UIControl<MTZFormField> *)fieldForFormObject {
    return self.textField;
}
@end
```

* Note that the form fields must conform to `MTZFormField`. The framework already provides a default implementation for `UITextField`, `UITextView`, `UISwitch` and `UIStepper`.

### Form date rows
Dates are a special topic. Due to that, if you want to interact with a `NSDate` key path, use `MTZTableFormDateRow` instead:
```objc
MTZTableFormDateRow *dateRow = [[MTZTableFormDateRow alloc] initWithClazz:[MyCustomTextFieldCell class] formObject:self.formObject keyPath:CLASSKEY(MyCustomFormObject, date)];
dateRow.minimumDate = [NSDate date];
dateRow.maximumDate = [[NSDate date] dateByAddingTimeInterval:60*60*24*15];
dateRow.datePickerMode = MTZDatePickerModeDateAndTime;
```

* `MTZTableFormDateRow` must also use `UITextField` as a form field, as we replace the `inputView` with the adequate picker. 
* You can also use `MTZDatePickerModeExpirationDate` as a picker mode, and it will use the `MTZExpirationDatePicker` as `inputView`.

### Form options
If you want to provide a set of options, do so by setting the `availableOptions` property on the `MTZTableFormRow`:
```objc
NSArray *allUsers = @[[[MyCustomUser alloc] initWithID:1 email:@"a@b.com"],
                          [[MyCustomUser alloc] initWithID:2 email:@"b@c.com"],
                          [[MyCustomUser alloc] initWithID:3 email:@"c@d.com"]];
MTZTableFormRow *userRow = [[MTZTableFormRow alloc] initWithClazz:[MyCustomTextFieldCell class] formObject:self.formObject keyPath:CLASSKEY(MyCustomFormObject, user)];
userRow.availableOptions = allUsers;
```

* This row will most likely require a converter to work properly, to be able to map to and from the field value.
* If you set available options, you must also use `UITextField` as a form field, as we replace the `inputView` with the adequate picker.

### Converters

### Validators

### Masker


# License
`MTZTableViewManager` is released under the MIT license. See LICENSE for details.
